# 递归
    就是方法自己调用自己,每次调用时 传入不同的变量.递归有助于编程者解决复杂的问题,同时
    可以让代码变得简洁。

## 递归调用机制
1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2) 方法的局部变量是独立的，不会相互影响, 比如 n 变量
3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
4) 递归 必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:)
5) 当一个方法执行完毕，或者遇到 return，就会返回， 遵守谁调用，就将结果返回给谁，同时当方法执行完毕或
者返回时，该方法也就执行完毕

## 递归调用规则：
1) 当程序执行到一个方法时 就会开辟一个独立空间（栈空间）
  eg:打印(test)问题 阶乘(factorial)问题
  ```java
     public static void test(int n) {
            if (n > 2) {
                test(n - 1);
            }//else { n =2
                System.out.println("n=" + n);
           // }
            //        n=2
    //        n=3
    //        n=4
        }
```
```java
 public static  int factorial(int n){
        if (n==1){
            return  1;
        }else{
            return factorial(n -1) * n;
        }

    }
```
2) 每个空间的数据（局部变量），是独立的，不会相互影响

## 递归能解决什么样的问题
递归用于解决什么样的问题
1) 各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google 编程大赛)
2) 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
3) 将用栈解决的问题-->第归代码比较简洁


## 递归-八皇后 问题(回溯算法)

### 八皇后问题介绍
八皇后问题，是一个古老而著名的问题，是
回溯算法的典型案例。该问题是国际西洋棋
棋手马克斯.贝瑟尔于1848年提出:在8X8格
的国际象棋上摆放八个皇后，使其不能互相
攻击，即:任意两个皇后都不能处于同QUEENS一行、同-列或同一斜线上，问有多少种摆法。

### 八皇后问题算法思路分析
1) 第一个皇后先放第一行第一列
2) 第二个皇后放在第二行第一列、然后判断是否OK[冲突]，如果不0K， 继续放在
第二列、第三列、依次把所有列都放完，找到一个合适
3) 继续第三个皇后，还是第一列、第二.....直到第8个皇后也能放在一个
不冲突的位置，算是找到了一个正确解
4) 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第
一个皇后，放到第一列的所有正确解，全部得到.
5) 然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤
   * 说明:理论上应该创建--个二维数组来表示棋盘，但是实际上可以通过算法
    用一个一维数组即可解决问题. arr[8]= {0,4, 7,5,2, 6, 1, 3} //对应arr下标表
    示第几行，即第几个皇后，arr[i]=val, val表示第i+1个皇后，放在第i+1行的
    ! 第val+1列
    
### 解法92种 打印如下

```aidl
        0 4 7 5 2 6 1 3
        0 5 7 2 6 3 1 4
        0 6 3 5 7 1 4 2
        0 6 4 7 1 3 5 2
        1 3 5 7 2 0 6 4
        1 4 6 0 2 7 5 3
        1 4 6 3 0 7 5 2
        1 5 0 6 3 7 2 4
        1 5 7 2 0 3 6 4
        1 6 2 5 7 4 0 3
        1 6 4 7 0 3 5 2
        1 7 5 0 2 4 6 3
        2 0 6 4 7 1 3 5
        2 4 1 7 0 6 3 5
        2 4 1 7 5 3 6 0
        2 4 6 0 3 1 7 5
        2 4 7 3 0 6 1 5
        2 5 1 4 7 0 6 3
        2 5 1 6 0 3 7 4
        2 5 1 6 4 0 7 3
        2 5 3 0 7 4 6 1
        2 5 3 1 7 4 6 0
        2 5 7 0 3 6 4 1
        2 5 7 0 4 6 1 3
        2 5 7 1 3 0 6 4
        2 6 1 7 4 0 3 5
        2 6 1 7 5 3 0 4
        2 7 3 6 0 5 1 4
        3 0 4 7 1 6 2 5
        3 0 4 7 5 2 6 1
        3 1 4 7 5 0 2 6
        3 1 6 2 5 7 0 4
        3 1 6 2 5 7 4 0
        3 1 6 4 0 7 5 2
        3 1 7 4 6 0 2 5
        3 1 7 5 0 2 4 6
        3 5 0 4 1 7 2 6
        3 5 7 1 6 0 2 4
        3 5 7 2 0 6 4 1
        3 6 0 7 4 1 5 2
        3 6 2 7 1 4 0 5
        3 6 4 1 5 0 2 7
        3 6 4 2 0 5 7 1
        3 7 0 2 5 1 6 4
        3 7 0 4 6 1 5 2
        3 7 4 2 0 6 1 5
        4 0 3 5 7 1 6 2
        4 0 7 3 1 6 2 5
        4 0 7 5 2 6 1 3
        4 1 3 5 7 2 0 6
        4 1 3 6 2 7 5 0
        4 1 5 0 6 3 7 2
        4 1 7 0 3 6 2 5
        4 2 0 5 7 1 3 6
        4 2 0 6 1 7 5 3
        4 2 7 3 6 0 5 1
        4 6 0 2 7 5 3 1
        4 6 0 3 1 7 5 2
        4 6 1 3 7 0 2 5
        4 6 1 5 2 0 3 7
        4 6 1 5 2 0 7 3
        4 6 3 0 2 7 5 1
        4 7 3 0 2 5 1 6
        4 7 3 0 6 1 5 2
        5 0 4 1 7 2 6 3
        5 1 6 0 2 4 7 3
        5 1 6 0 3 7 4 2
        5 2 0 6 4 7 1 3
        5 2 0 7 3 1 6 4
        5 2 0 7 4 1 3 6
        5 2 4 6 0 3 1 7
        5 2 4 7 0 3 1 6
        5 2 6 1 3 7 0 4
        5 2 6 1 7 4 0 3
        5 2 6 3 0 7 1 4
        5 3 0 4 7 1 6 2
        5 3 1 7 4 6 0 2
        5 3 6 0 2 4 1 7
        5 3 6 0 7 1 4 2
        5 7 1 3 0 6 4 2
        6 0 2 7 5 3 1 4
        6 1 3 0 7 4 2 5
        6 1 5 2 0 3 7 4
        6 2 0 5 7 4 1 3
        6 2 7 1 4 0 5 3
        6 3 1 4 7 0 2 5
        6 3 1 7 5 0 2 4
        6 4 2 0 5 7 1 3
        7 1 3 0 6 4 2 5
        7 1 4 2 0 6 3 5
        7 2 0 5 1 4 6 3
        7 3 0 2 5 1 6 4
        queue 8 一共 92 解法
```    