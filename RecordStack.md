# 栈
    引用：[7*2*2-5+1-5+3-3] 对计算机而言，它接收到的就是一个字符串
    
### 栈的介绍
1) 栈的英文为(stack)
2) 栈是一个 先入后出(FILO-First In Last Out) 的有序列表。
3) 栈(stack) 是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。 。 允许插入和删除的
一端，为 变化的一端，称为栈顶(Top) ，另一端为 固定的一端，称为栈底(Bottom) 。
4) 根据栈的定义可知 ， 最先放入栈中元素在栈底 ， 最后放入的元素在栈顶 ， 而删除元素刚好相反 ， 最后放入的元
素最先删除，最先放入的元素最后删除

### 栈的应用场景
1) 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以
    回到原来的程序中。
2) 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆
    栈中。
3) 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
4) 二叉树的遍历。
5) 图形的深度优先(depth 一 first)搜索法。


### 栈的快速入门
* 用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，
  下面我们就用数组模拟栈的出栈，入栈等操作。
  
  1) 使用数组来模拟栈
  2) 定义一个top来表示栈顶，初始化为-1
  3) 入栈的动作，当有数据加入到栈时，top++ stack[top]=data
  4) 出栈的操作，int value = stack[top] top-- return value
  
### 栈实现综合计算器(中缀表达式)  
    处理多位数时 不能发现是一个数就立即入栈
    在处理数 需要向expression的表达式的index  后在看以为 如果是数就进行扫描
    是符号才入栈
    定义一个变量（字符串） 用于拼接
* 通过一个index值（索引）宾利来遍历我们的表达式
* 发现一个数字 就直接入数栈 
* 发现是符号 
  * 如果发现符号栈为空 直接入栈
  * 如果符号栈有操作符 就进行比较 当前的操作符优先级小于或者等于栈中的操作符 这是就需要从书展中pop出两个数 再从符号栈中pop出一个符号 进行运算 将得到结果 入数栈 然后将当前的操作符入符号栈
  * 如果当前的操作符优先级大于栈中的操作符 就直接入符号栈  不进行计算
* 当表达式扫描完毕之后 就顺序的从数栈和符号栈pop出响应的数字和符号 并运行
* 最后数栈只有一个数字 就是符号表达式的结果

## 前缀、中缀、后缀表达式

### 前缀（波兰）表达式
    前缀表达式：运算符位于数值前，从右至左扫描 eg:（3+4）x5-6 ||  -x+3456
    从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算(栈项元素和次顶元素)，并将结果入栈;重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果
    例如: (3+4)X5-6对应的前缀表达式就是- X +3456,针对前缀表达式求值步骤如下:
*  从右至左扫描，将6、5、4、3压入堆栈
*  遇到+运算符，因此弹出3和4 (3为栈项元素，4为次顶元素)，计算出3+4的值，得7,再将7入栈
*  接下来是X运算符，因此弹出7和5， 计算出7X5=35，将35入栈
*  最后是运算符，计算出35-6的值，即29， 由此得出最终结果

### 中缀表达式 
    常见的运算表达式 对计算机并不好操作 eg:（3+4）x5 -6
    中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例
    就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作
    (-般转成后缀表达式.)
    
### 后缀（逆波兰）表达式 
    位于操作数之后 从左至右扫描 对计算机操作最好 eg:（3+4）x5 -6 || 34 + 5x6 -
    
### 中缀表达式转换为后缀表达式
    大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式
    很长的情况下，因此在开发中，我们需要将中缀表达式转成后缀表达式。
    具体步骤如下:
* 初始化两个栈:运算符栈s1和储存中间结果的栈s2;
* 从左至右扫描中缀表达式;
* 遇到操作数时，将其压s2;
* 遇到运算符时，比较其与s1栈顶运算符的优先级:
    * 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈;
    * 否则，若优先级比栈顶运算符的高，也将运算符压入s1;
    * 否则(（当item的优先级 <= 栈顶运算符优先级）)，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算
    符相比较;
* 遇到括号时:
    * 如果是左括号“("，则直接压入s1
    * 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为
    止，此时将这一对括号丢弃
* 重复步骤2至5， 直到表达式的最右边
* 将s1中 剩余的运算符依次弹出并压入s2
* 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式