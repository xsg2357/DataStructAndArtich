# 链表
    链表是有序的列表
1) 链表是以节点的方式来存储, 是链式存储
2) 每个节点包含 data 域， next 域：指向下一个节点.
3) 链表的各个节点不一定是连续存储.
4) 链表分 带头节点的链表和 没有头节点的链表，根据实际的需求来确定    

## 单向链表
1) 使用带 head 头的单向链表实现 –水浒英雄排行榜管理完成对英雄人物的增删改查操作， 注: 删除和修改,查找
      * head节点：不存放具体的数据，作用就是表示单链表头结点添加（创建）：
              1) 先创建一个head头甲店，左右就是表示单链表的头
              2) 后面没添加一个节点，就直接加入到单链表的头
      * 遍历：通过一个辅助遍历，帮助遍历整个单链表
2) 在添加英雄时， 根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)
    需要按照编号的顺序添加
    * 首先找到新添加节点的位置，通过辅助变量指针（遍历来搞定）
    * 新的节点.next = temp.next
    * 将temp.next = 新的节点

3) 修改节点功能
   思路(1) 先找到该节点，通过遍历，(2) temp.name = newHeroNode.name ; temp.nickname= newHeroNode.nickname

4) 删除节点
    * 先找到需要删除的这个节点的前一个节点temp
    * temp.next = temp.next.next
    * 被删除的节点，将不会有其他引用指向，会被垃圾回收机制回收掉


5) 反转节点
    * 先定义一个节点reverseHead = new HeroNode（）
    * 从头到尾遍历原来的链表 每遍历一个节点 就将其取出 就放在链表的最前端
    * 原来的链表的head.next = reverseHead.next
    
##  双向链表
分析双向链表的遍历、添加、修改、删除的操作思路:
1) 遍历方法和单链表一样 实时可以镶嵌，也可以向后查找
2) 添加（默认添加到双向链表的最后）
    * 先找到双向链表的最后这个节点 tem.next = newHeroNode   newHeroNode.pre = temp
3) 修改思路原理和单向列表一样
4) 删除
   * 因为是双线链表 因此 我们可以实现自我删除的某个节点
   * 直接找到要删除的这个节点 比如temp
   * temp.pre.next = tem.next
   * temp.next.pre = tem.pre

##  单向环形链表（约瑟夫问题）
    
    Josephu(约瑟夫、约瑟夫环) 问题
    Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数
    到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由
    此产生一个出队编号的序列。
    提示：用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结
    点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直
    到最后一个结点从链表中删除算法结束
    
```mxml
    n =5 有5个人 
    k=1 从第一个人开始报数 单向环形链表完成约瑟夫问题
    m =2 数2下
    出圈顺序 2 4 1 3
```
* 构建一个单向的环形链表思路：
    1) 先创建第一个几点 让first指向该节点 并形成环形
    2) 后面当我们每创建一个新的节点 就把该节点 加入到已有的环形链表即可
* 遍历环形列表
    1) 显然一个辅助变量 指向first节点
    2) 然后通过一个while循环遍历该环形链表即可 curBoy.next == first结束
    
* 根据用户的的输入 生成一个小孩出圈的顺序
    1) 传建一个辅助指针 helper 事先应该指向环形列表的最后这个节点
      补充：小孩报数前 先让first和heler移动k-1次
    2) 当小孩报数时 让first和helper指针同时移动m-1次
    3) 这时就可以将first指向的小孩节点出圈
      first = first.next
      helper.next = first
      原来的first节点就没有任何引用，就会被系统回收掉        
    
    